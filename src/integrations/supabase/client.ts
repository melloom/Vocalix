// This file is automatically generated. Do not edit it directly.
import { createClient } from "@supabase/supabase-js";
import type { Database } from "./types";
import { getUserAgent, validateDeviceMetadata, isSuspiciousDeviceId, generateDeviceFingerprint } from "@/lib/deviceSecurity";

const SUPABASE_URL = import.meta.env.VITE_SUPABASE_URL;
const SUPABASE_PUBLISHABLE_KEY = import.meta.env.VITE_SUPABASE_PUBLISHABLE_KEY;

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

// Cache to track which RPC functions exist (to avoid repeated 404s)
const rpcFunctionCache = new Set<string>();
const missingRpcFunctions = new Set<string>();

// Load cached missing functions from localStorage on initialization
const loadMissingFunctionsCache = () => {
  try {
    const cached = localStorage.getItem("missing_rpc_functions");
    if (cached) {
      const functions = JSON.parse(cached);
      functions.forEach((fn: string) => missingRpcFunctions.add(fn));
    }
  } catch (error) {
    // Ignore parse errors
  }
};

// Save missing functions to localStorage
const saveMissingFunctionsCache = () => {
  try {
    localStorage.setItem("missing_rpc_functions", JSON.stringify(Array.from(missingRpcFunctions)));
  } catch (error) {
    // Ignore storage errors
  }
};

// Initialize cache on load
loadMissingFunctionsCache();

// Suppress WebSocket connection errors from Supabase Realtime (non-critical)
// These errors occur when Realtime can't connect, but the app works fine without real-time updates
if (typeof window !== "undefined") {
  const originalError = console.error;
  console.error = (...args: any[]) => {
    // Check if this is a Supabase Realtime WebSocket error
    const errorString = args.map(arg => String(arg)).join(" ");
    if (
      errorString.includes("WebSocket") &&
      errorString.includes("supabase.co/realtime") &&
      (errorString.includes("failed") || errorString.includes("closed") || errorString.includes("connection"))
    ) {
      // Silently ignore - these are non-critical
      return;
    }
    // Log all other errors normally
    originalError.apply(console, args);
  };
}

// PERMANENTLY disable create_session until PostgREST cache refreshes
// This prevents all 404 console errors
if (typeof window !== "undefined") {
  missingRpcFunctions.add("create_session");
  saveMissingFunctionsCache();
  
  // Also set a flag to completely disable session creation
  localStorage.setItem("disable_session_creation", "true");
}

// Helper to get cookie value
function getCookie(name: string): string | null {
  if (typeof document === "undefined") return null;
  const value = `; ${document.cookie}`;
  const parts = value.split(`; ${name}=`);
  if (parts.length === 2) return parts.pop()?.split(';').shift() || null;
  return null;
}

// Helper to hash token (SHA-256)
async function hashToken(token: string): Promise<string> {
  const encoder = new TextEncoder();
  const data = encoder.encode(token);
  const hashBuffer = await crypto.subtle.digest("SHA-256", data);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  return hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
}

// Helper function to call RPC functions using native fetch (bypasses custom fetch to avoid circular dependency)
// This is used for non-critical background operations and fails silently if the function doesn't exist
const callRpcNative = async (functionName: string, params: Record<string, any>) => {
  // Skip if we know this function doesn't exist
  if (missingRpcFunctions.has(functionName)) {
    return null;
  }

  try {
    const response = await fetch(`${SUPABASE_URL}/rest/v1/rpc/${functionName}`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "apikey": SUPABASE_PUBLISHABLE_KEY,
        "Authorization": `Bearer ${SUPABASE_PUBLISHABLE_KEY}`,
      },
      body: JSON.stringify(params),
    });
    
    // Silently handle 404 (function doesn't exist) - cache it to avoid future calls
    if (response.status === 404) {
      missingRpcFunctions.add(functionName);
      saveMissingFunctionsCache();
      return null;
    }
    
    if (!response.ok) {
      // For other errors, try to parse but don't throw - just return null
      await response.json().catch(() => null);
      return null;
    }
    
    // Function exists - cache it and remove from missing list if it was there
    rpcFunctionCache.add(functionName);
    if (missingRpcFunctions.has(functionName)) {
      missingRpcFunctions.delete(functionName);
      saveMissingFunctionsCache();
    }
    return await response.json();
  } catch (error) {
    // Silently fail - these are non-critical background operations
    // Don't log errors to avoid console spam
    return null;
  }
};

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
  auth: {
    storage: localStorage,
    persistSession: true,
    autoRefreshToken: true,
  },
  realtime: {
    // Suppress WebSocket connection errors in console
    // These are non-critical - app works without real-time updates
    params: {
      eventsPerSecond: 10,
    },
  },
  global: {
    fetch: async (url, options: RequestInit = {}) => {
      const existingHeaders = options.headers;
      const headers = existingHeaders instanceof Headers 
        ? existingHeaders 
        : new Headers(existingHeaders as HeadersInit | undefined);
      
      // Try multiple storage mechanisms for device ID (important for mobile)
      let deviceId: string | null = null;
      try {
        deviceId = localStorage.getItem("deviceId");
      } catch (e) {
        // localStorage might not be available (private browsing, quota exceeded, etc.)
      }
      
      // Fallback to sessionStorage if localStorage failed
      if (!deviceId) {
        try {
          deviceId = sessionStorage.getItem("deviceId");
        } catch (e) {
          // sessionStorage also not available
        }
      }

      // Get URL string once for all checks
      const urlString = url.toString();

      // Note: We don't use credentials: 'include' for Supabase API calls
      // because Supabase uses localStorage for auth, not cookies.
      // Session tokens are sent as headers (x-session-token-hash) instead.
      // credentials: 'include' is only used for edge functions that set cookies.

      // Get session token from cookie and send hash in header
      const sessionToken = getCookie('echo_session');
      if (sessionToken) {
        try {
          const tokenHash = await hashToken(sessionToken);
          headers.set("x-session-token-hash", tokenHash);
        } catch (error) {
          console.warn("Failed to hash session token:", error);
        }
      }

      if (deviceId) {
        // Security: Validate device ID before using it
        if (isSuspiciousDeviceId(deviceId)) {
          console.error("Suspicious device ID detected:", deviceId);
          // Don't send suspicious device ID - let server handle it
        } else {
          headers.set("x-device-id", deviceId);
          
          // Validate device metadata only on important requests (not storage/CDN requests)
          // This reduces unnecessary fingerprint generation and validation
          const isStorageRequest = urlString.includes("/storage/v1/");
          const isCDNRequest = urlString.includes("/cdn/");
          
          // Only validate on non-storage requests to reduce frequency
          if (!isStorageRequest && !isCDNRequest) {
            // Throttle validation - only validate once per 30 seconds
            // Wrap in try-catch to prevent blocking requests if validation fails
            try {
              const lastValidationKey = "last_device_validation";
              const lastValidation = sessionStorage.getItem(lastValidationKey);
              const now = Date.now();
              const validationInterval = 30000; // 30 seconds
              
              if (!lastValidation || (now - parseInt(lastValidation, 10)) > validationInterval) {
                const validation = validateDeviceMetadata(deviceId);
                if (!validation.isValid) {
                  console.warn("Device validation failed:", validation.reason);
                }
                sessionStorage.setItem(lastValidationKey, now.toString());
              }
            } catch (validationError) {
              // Don't block requests if validation fails
              console.debug("Device validation error (non-blocking):", validationError);
            }
          }
        }
        
        // Add user agent for security tracking
        headers.set("x-user-agent", getUserAgent());
      }

      // CDN optimization: Add cache headers for storage requests
      if (urlString.includes("/storage/v1/object/") || urlString.includes("/storage/v1/object/sign/")) {
        // For audio files, use cache-first strategy
        headers.set("Cache-Control", "public, max-age=3600, stale-while-revalidate=86400");
      }
      
      // Don't send x-user-agent header to edge functions (causes CORS issues)
      if (urlString.includes("/functions/v1/")) {
        headers.delete("x-user-agent");
      }

      try {
        // Don't include credentials for Supabase API calls (causes CORS issues)
        // Supabase uses localStorage for auth, not cookies
        
        // Suppress 404 errors for create_session RPC calls (PostgREST cache issue)
        const isCreateSessionRpc = urlString.includes("/rest/v1/rpc/create_session");
        if (isCreateSessionRpc && missingRpcFunctions.has("create_session")) {
          // Don't even make the request if we know it's missing
          return new Response(
            JSON.stringify({ error: "Function not found", code: "PGRST301" }),
            { status: 404, statusText: "Not Found" }
          );
        }
        
        const response = await fetch(url, { ...options, headers });
        
        // Silently handle 404 for create_session (suppress console errors)
        if (isCreateSessionRpc && response.status === 404) {
          missingRpcFunctions.add("create_session");
          saveMissingFunctionsCache();
          // Return a response that won't cause console errors
          return new Response(
            JSON.stringify({ error: "Function not found", code: "PGRST301" }),
            { status: 404, statusText: "Not Found" }
          );
        }
        
        // Track device activity on successful requests (non-blocking)
        // Use native fetch to avoid circular dependency
        // Silently handle 404s - function may not exist yet (migrations not run)
        if (deviceId && response.ok && !urlString.includes("/storage/")) {
          // Update device activity with session management in background (fire-and-forget)
          // Try new session-aware function first, fall back to old function for backward compatibility
          callRpcNative("update_device_activity_with_session", {
            p_device_id: deviceId,
            p_user_agent: getUserAgent(),
            p_auto_refresh_session: true,
          }).catch((err) => {
            // Silently ignore 404s - function may not exist
            if (err?.message?.includes("404") || err?.message?.includes("not found") || err?.message?.includes("does not exist")) {
              return; // Silently ignore
            }
            // Fall back to old function if new one doesn't exist
            callRpcNative("update_device_activity", {
              p_device_id: deviceId,
              p_user_agent: getUserAgent(),
            }).catch((fallbackErr) => {
              // Silently ignore 404s and "not found" errors
              if (fallbackErr?.message?.includes("404") || 
                  fallbackErr?.message?.includes("not found") || 
                  fallbackErr?.message?.includes("does not exist")) {
                return; // Silently ignore
              }
              // Only log other errors
              if (fallbackErr?.message) {
                console.warn("Failed to update device activity:", fallbackErr);
              }
            });
          });
        }
        
        return response;
      } catch (error) {
        // Log failed requests for security monitoring
        // Use native fetch to avoid circular dependency
        // Note: This will show 404 errors in console if migrations haven't been run yet
        if (deviceId) {
          callRpcNative("record_failed_auth", {
            p_device_id: deviceId,
            p_reason: error instanceof Error ? error.message : "Unknown error",
          }).catch(() => {
            // Silently ignore - function may not exist yet
          });
        }
        throw error;
      }
    },
  },
});

export const updateSupabaseDeviceHeader = async (deviceId: string, oldDeviceId?: string | null) => {
  const previousDeviceId = localStorage.getItem("deviceId");
  const actualOldDeviceId = oldDeviceId || previousDeviceId;
  
  // Only track if device ID actually changed
  if (actualOldDeviceId && actualOldDeviceId !== deviceId) {
    try {
      // Get current profile ID
      const profileId = localStorage.getItem("profileId");
      
      if (profileId) {
        // Validate new device ID format and check if it can be used
        const { data: validationResult, error: validationError } = await supabase
          .rpc('can_use_device_id', {
            p_device_id: deviceId,
            p_profile_id: profileId
          });

        if (validationError) {
          console.error("Device ID validation error:", validationError);
          // Don't block - allow but log error
        } else if (validationResult && validationResult.length > 0 && !validationResult[0].allowed) {
          console.error("Device ID validation failed:", validationResult[0].reason);
          // Don't update if validation failed
          return;
        }

        // Check rotation limit
        const { data: rotationCheck, error: rotationError } = await supabase
          .rpc('check_device_rotation_limit', {
            p_profile_id: profileId,
            p_new_device_id: deviceId,
            p_max_rotations_per_day: 3
          });

        if (rotationError) {
          console.error("Device rotation limit check error:", rotationError);
        } else if (rotationCheck && rotationCheck.length > 0 && !rotationCheck[0].allowed) {
          console.error("Device rotation limit exceeded:", rotationCheck[0].reason);
          // Don't update if limit exceeded
          return;
        }

        // Track device ID change with fingerprint binding
        const deviceFingerprint = generateDeviceFingerprint();
        const { error: trackError } = await supabase
          .rpc('track_device_id_change', {
            p_profile_id: profileId,
            p_old_device_id: actualOldDeviceId,
            p_new_device_id: deviceId,
            p_ip_address: null, // Will be set by server if available
            p_user_agent: getUserAgent(),
            p_device_fingerprint: deviceFingerprint, // Client-side fingerprint for binding
            p_rotation_reason: 'client_side_change'
          });

        if (trackError) {
          console.error("Failed to track device ID change:", trackError);
          // Continue anyway - non-critical
        }
      }
    } catch (error) {
      console.error("Error validating device ID change:", error);
      // Continue anyway - don't block legitimate users
    }
  }
  
  // Update stored device ID
  localStorage.setItem("deviceId", deviceId);
};

// Helper function to set session cookie via Netlify function (or Supabase edge function as fallback)
export const setSessionCookie = async (sessionToken: string): Promise<boolean> => {
  try {
    // Try Netlify function first (for production on echogarden.netlify.app)
    // Falls back to Supabase edge function if Netlify function is not available
    const netlifyFunctionUrl = "/.netlify/functions/set-session-cookie";
    const supabaseFunctionUrl = `${SUPABASE_URL}/functions/v1/set-session-cookie`;
    
    // Determine which URL to use based on current origin
    const isNetlify = typeof window !== "undefined" && 
      (window.location.hostname.includes("netlify.app") || 
       window.location.hostname.includes("echogarden"));
    
    const functionUrl = isNetlify ? netlifyFunctionUrl : supabaseFunctionUrl;
    
    const response = await fetch(functionUrl, {
      method: "POST",
      credentials: 'include',
      headers: {
        "Content-Type": "application/json",
        ...(isNetlify ? {} : { "Authorization": `Bearer ${SUPABASE_PUBLISHABLE_KEY}` }),
      },
      body: JSON.stringify({ token: sessionToken }),
    });

    if (!response.ok) {
      // If Netlify function fails, try Supabase edge function as fallback
      if (isNetlify && response.status >= 500) {
        console.warn("Netlify function failed, trying Supabase edge function as fallback");
        const fallbackResponse = await fetch(supabaseFunctionUrl, {
          method: "POST",
          credentials: 'include',
          headers: {
            "Content-Type": "application/json",
            "Authorization": `Bearer ${SUPABASE_PUBLISHABLE_KEY}`,
          },
          body: JSON.stringify({ token: sessionToken }),
        });
        
        if (fallbackResponse.ok) {
          return true;
        }
      }
      
      const error = await response.json().catch(() => ({ error: "Unknown error" }));
      console.error("Failed to set session cookie:", error);
      return false;
    }

    return true;
  } catch (error) {
    console.error("Error setting session cookie:", error);
    return false;
  }
};

// Export function to check if RPC function exists (useful for conditional logic)
export const checkRpcFunctionExists = (functionName: string): boolean => {
  return !missingRpcFunctions.has(functionName);
};

// Initialize RPC function availability check on app startup
// This runs once to check if critical functions exist and cache the result
export const initializeRpcFunctionCheck = async () => {
  // Only check functions that we know might not exist yet
  const functionsToCheck = ["update_device_activity", "get_user_devices"];
  
  for (const functionName of functionsToCheck) {
    // Skip if already cached
    if (missingRpcFunctions.has(functionName) || rpcFunctionCache.has(functionName)) {
      continue;
    }
    
    // Quick check: try to call with minimal params
    try {
      const response = await fetch(`${SUPABASE_URL}/rest/v1/rpc/${functionName}`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "apikey": SUPABASE_PUBLISHABLE_KEY,
          "Authorization": `Bearer ${SUPABASE_PUBLISHABLE_KEY}`,
        },
        body: JSON.stringify({}),
      });
      
      if (response.status === 404) {
        missingRpcFunctions.add(functionName);
        saveMissingFunctionsCache();
      } else if (response.ok || response.status === 400) {
        // 400 usually means wrong params but function exists
        rpcFunctionCache.add(functionName);
        if (missingRpcFunctions.has(functionName)) {
          missingRpcFunctions.delete(functionName);
          saveMissingFunctionsCache();
        }
      }
    } catch (error) {
      // Ignore errors during initialization check
    }
  }
};