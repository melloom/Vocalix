// This file is automatically generated. Do not edit it directly.
import { createClient } from "@supabase/supabase-js";
import type { Database } from "./types";
import { getUserAgent, validateDeviceMetadata, isSuspiciousDeviceId } from "@/lib/deviceSecurity";

const SUPABASE_URL = import.meta.env.VITE_SUPABASE_URL;
const SUPABASE_PUBLISHABLE_KEY = import.meta.env.VITE_SUPABASE_PUBLISHABLE_KEY;

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

// Cache to track which RPC functions exist (to avoid repeated 404s)
const rpcFunctionCache = new Set<string>();
const missingRpcFunctions = new Set<string>();

// Load cached missing functions from localStorage on initialization
const loadMissingFunctionsCache = () => {
  try {
    const cached = localStorage.getItem("missing_rpc_functions");
    if (cached) {
      const functions = JSON.parse(cached);
      functions.forEach((fn: string) => missingRpcFunctions.add(fn));
    }
  } catch (error) {
    // Ignore parse errors
  }
};

// Save missing functions to localStorage
const saveMissingFunctionsCache = () => {
  try {
    localStorage.setItem("missing_rpc_functions", JSON.stringify(Array.from(missingRpcFunctions)));
  } catch (error) {
    // Ignore storage errors
  }
};

// Initialize cache on load
loadMissingFunctionsCache();

// Helper function to call RPC functions using native fetch (bypasses custom fetch to avoid circular dependency)
// This is used for non-critical background operations and fails silently if the function doesn't exist
const callRpcNative = async (functionName: string, params: Record<string, any>) => {
  // Skip if we know this function doesn't exist
  if (missingRpcFunctions.has(functionName)) {
    return null;
  }

  try {
    const response = await fetch(`${SUPABASE_URL}/rest/v1/rpc/${functionName}`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "apikey": SUPABASE_PUBLISHABLE_KEY,
        "Authorization": `Bearer ${SUPABASE_PUBLISHABLE_KEY}`,
      },
      body: JSON.stringify(params),
    });
    
    // Silently handle 404 (function doesn't exist) - cache it to avoid future calls
    if (response.status === 404) {
      missingRpcFunctions.add(functionName);
      saveMissingFunctionsCache();
      return null;
    }
    
    if (!response.ok) {
      // For other errors, try to parse but don't throw - just return null
      await response.json().catch(() => null);
      return null;
    }
    
    // Function exists - cache it and remove from missing list if it was there
    rpcFunctionCache.add(functionName);
    if (missingRpcFunctions.has(functionName)) {
      missingRpcFunctions.delete(functionName);
      saveMissingFunctionsCache();
    }
    return await response.json();
  } catch (error) {
    // Silently fail - these are non-critical background operations
    // Don't log errors to avoid console spam
    return null;
  }
};

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
  auth: {
    storage: localStorage,
    persistSession: true,
    autoRefreshToken: true,
  },
  global: {
    fetch: async (url, options: RequestInit = {}) => {
      const existingHeaders = options.headers;
      const headers = existingHeaders instanceof Headers 
        ? existingHeaders 
        : new Headers(existingHeaders as HeadersInit | undefined);
      const deviceId = localStorage.getItem("deviceId");

      if (deviceId) {
        // Security: Validate device ID before using it
        if (isSuspiciousDeviceId(deviceId)) {
          console.error("Suspicious device ID detected:", deviceId);
          // Don't send suspicious device ID - let server handle it
        } else {
          headers.set("x-device-id", deviceId);
          
          // Validate device metadata
          const validation = validateDeviceMetadata(deviceId);
          if (!validation.isValid) {
            console.warn("Device validation failed:", validation.reason);
          }
        }
        
        // Add user agent for security tracking
        headers.set("x-user-agent", getUserAgent());
      }

      // CDN optimization: Add cache headers for storage requests
      const urlString = url.toString();
      if (urlString.includes("/storage/v1/object/") || urlString.includes("/storage/v1/object/sign/")) {
        // For audio files, use cache-first strategy
        headers.set("Cache-Control", "public, max-age=3600, stale-while-revalidate=86400");
      }
      
      // Don't send x-user-agent header to edge functions (causes CORS issues)
      if (urlString.includes("/functions/v1/")) {
        headers.delete("x-user-agent");
      }

      try {
        const response = await fetch(url, { ...options, headers });
        
        // Track device activity on successful requests (non-blocking)
        // Use native fetch to avoid circular dependency
        // Note: This will show 404 errors in console if migrations haven't been run yet
        // These errors are harmless and will disappear once update_device_activity function is deployed
        if (deviceId && response.ok && !urlString.includes("/storage/")) {
          // Update device activity in background using native fetch (fire-and-forget)
          // Call update_device_activity to keep last_seen_at current
          callRpcNative("update_device_activity", {
            p_device_id: deviceId,
            p_user_agent: getUserAgent(),
          }).catch((err) => {
            // Only log if it's not a "function doesn't exist" error
            if (err?.message && !err.message.includes("does not exist") && !err.message.includes("not found")) {
              console.warn("Failed to update device activity:", err);
            }
          });
        }
        
        return response;
      } catch (error) {
        // Log failed requests for security monitoring
        // Use native fetch to avoid circular dependency
        // Note: This will show 404 errors in console if migrations haven't been run yet
        if (deviceId) {
          callRpcNative("record_failed_auth", {
            p_device_id: deviceId,
            p_reason: error instanceof Error ? error.message : "Unknown error",
          }).catch(() => {
            // Silently ignore - function may not exist yet
          });
        }
        throw error;
      }
    },
  },
});

export const updateSupabaseDeviceHeader = (deviceId: string) => {
  localStorage.setItem("deviceId", deviceId);
};

// Export function to check if RPC function exists (useful for conditional logic)
export const checkRpcFunctionExists = (functionName: string): boolean => {
  return !missingRpcFunctions.has(functionName);
};

// Initialize RPC function availability check on app startup
// This runs once to check if critical functions exist and cache the result
export const initializeRpcFunctionCheck = async () => {
  // Only check functions that we know might not exist yet
  const functionsToCheck = ["update_device_activity", "get_user_devices"];
  
  for (const functionName of functionsToCheck) {
    // Skip if already cached
    if (missingRpcFunctions.has(functionName) || rpcFunctionCache.has(functionName)) {
      continue;
    }
    
    // Quick check: try to call with minimal params
    try {
      const response = await fetch(`${SUPABASE_URL}/rest/v1/rpc/${functionName}`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "apikey": SUPABASE_PUBLISHABLE_KEY,
          "Authorization": `Bearer ${SUPABASE_PUBLISHABLE_KEY}`,
        },
        body: JSON.stringify({}),
      });
      
      if (response.status === 404) {
        missingRpcFunctions.add(functionName);
        saveMissingFunctionsCache();
      } else if (response.ok || response.status === 400) {
        // 400 usually means wrong params but function exists
        rpcFunctionCache.add(functionName);
        if (missingRpcFunctions.has(functionName)) {
          missingRpcFunctions.delete(functionName);
          saveMissingFunctionsCache();
        }
      }
    } catch (error) {
      // Ignore errors during initialization check
    }
  }
};